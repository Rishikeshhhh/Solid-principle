#Solid Principle

#Single Responsibility Principle (SRP):
This principle states that a class should have only one reason to change, meaning it should have only one responsibility or job. By separating concerns, a class becomes more maintainable and less prone to bugs.

#Open/Closed Principle (OCP):
The Open/Closed Principle states that software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means that you should be able to extend the behavior of a class without modifying its source code.

#Liskov Substitution Principle (LSP):
This principle defines that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. In other words, a subclass should behave in such a way that it does not break the functionality that the superclass promises.

#Interface Segregation Principle (ISP):
ISP suggests that a client should not be forced to depend on interfaces that it does not use. Instead of having large, monolithic interfaces, it's better to have smaller, more specific interfaces tailored to the needs of the clients.

#Dependency Inversion Principle (DIP):
DIP states that high-level modules should not depend on low-level modules but should depend on abstractions. This principle promotes decoupling between modules by introducing interfaces or abstract classes that serve as contracts between them.
